S,v
>,v
",v
,V
" The magical turn-Vim-into-a-Python-IDE vim resource file!"" Mostly taken from http://www.sontek.net/category/Vim.aspx" Other bits culled from various sources, Canonical guys, or made up by me."" Julian Edwards 2008-05-30" Wrapping and tabs.set tw=78 ts=4 sw=4 sta et sts=4 ai" More syntax highlighting.let python_highlight_all = 1" Smart indentingset smartindent cinwords=if,elif,else,for,while,try,except,finally,def,class" Auto completion via ctrl-space (instead of the nasty ctrl-x ctrl-o)set omnifunc=pythoncomplete#Completeinoremap <Nul> <C-x><C-o>" Get this plugin from http://www.vim.org/scripts/script.php?script_id=1112" Pressing "K" takes you to the documentation for the word under the cursor.autocmd filetype python source ~/.vim/pydoc.vim" Wrap at 72 chars for comments.set formatoptions=cq textwidth=72 foldignore= wildignore+=*.py[co]" Highlight end of line whitespace.highlight WhitespaceEOL ctermbg=red guibg=redmatch WhitespaceEOL /\s\+$/" The next two highlight matches break the previous one, I don't know why." Show long lines."highlight LongLine guibg=red ctermbg=red"match LongLine /\%>79v.\+/" Highlight bzr merge markers."highlight MergeMarker guibg=red ctermbg=red"match MergeMarker /^[<=>\|]\{7\}\( [A-Z]\+\)?$/" `gf` jumps to the filename under the cursor.  Point at an import statement" and jump to it!python << EOFimport osimport sysimport vimfor p in sys.path:    if os.path.isdir(p):        vim.command(r"set path+=%s" % (p.replace(" ", r"\ ")))EOF" Generate tags with: ctags -R -f ~/.vim/tags/python24.ctags /usr/lib/python2.4/" ctrl-[ to go to the tag under the cursor, ctrl-T to go back.set tags+=$HOME/.vim/tags/python24.ctags" Use :make to see syntax errors. (:cn and :cp to move around, :dist to see" all errors)set makeprg=python\ -c\ \"import\ py_compile,sys;\ sys.stderr=sys.stdout;\ py_compile.compile(r'%')\"set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m" Execute a selection of code (very cool!)" Use VISUAL to select a range and then hit ctrl-h to execute it.python << EOLimport vimdef EvaluateCurrentRange():    eval(compile('\n'.join(vim.current.range),'','exec'),globals())EOLmap <C-h> :py EvaluateCurrentRange()" Use F7/Shift-F7 to add/remove a breakpoint (pdb.set_trace)" Totally cool.python << EOFdef SetBreakpoint():    import re    nLine = int( vim.eval( 'line(".")'))    strLine = vim.current.line    strWhite = re.search( '^(\s*)', strLine).group(1)    vim.current.buffer.append(       "%(space)spdb.set_trace() %(mark)s Breakpoint %(mark)s" %         {'space':strWhite, 'mark': '#' * 30}, nLine - 1)    for strLine in vim.current.buffer:        if strLine == "import pdb":            break    else:        vim.current.buffer.append( 'import pdb', 0)        vim.command( 'normal j1')vim.command( 'map <f7> :py SetBreakpoint()<cr>')def RemoveBreakpoints():    import re    nCurrentLine = int( vim.eval( 'line(".")'))    nLines = []    nLine = 1    for strLine in vim.current.buffer:        if strLine == "import pdb" or strLine.lstrip()[:15] == "pdb.set_trace()":            nLines.append( nLine)        nLine += 1    nLines.reverse()    for nLine in nLines:        vim.command( "normal %dG" % nLine)        vim.command( "normal dd")        if nLine < nCurrentLine:            nCurrentLine -= 1    vim.command( "normal %dG" % nCurrentLine)vim.command( "map <s-f7> :py RemoveBreakpoints()<cr>")EOFvim:syntax=vim,v
source ~/.vim_runtime/bundle/delimitMate/plugin/delimitMate.vimsource ~/.vim_runtime/bundle/syntastic/*source ~/.vim_runtime/bundle/vim-surround/plugin/surround.vim,V
"source ~/.vim_runtime/bundle/SimpylFold/ftplugin/python/SimpylFold.vim,V
filetype on			" Enable filetype detectionfiletype indent on	" Enable filetype-specific indentingfiletype plugin on	" Enable filetype-specific plugins,V
set expandtab 		" will convert tabs to spaces,V
set incsearch		" incremental search,V
set ignorecase		" ignore case when searching,V
set hlsearch		" search highlighting,V
set textwidth=80,V
set number              " shows line numbers,V
set smartcase		" ignore case if search pattern is all                         " lowercase,case-sensitive otherwise,V
set autoread		" auto read when file is changed from outside,V
setlocal spell spelllang=en_us   " Allows for spellchecking,V
" Color columnset colorcolumn=+1        " highlight column after 'textwidth'set colorcolumn=+1,+2,+3  " highlight three columns after 'textwidth'highlight ColorColumn ctermbg=lightgrey guibg=lightgreyset colorcolumn=80set numberwidth=3set cpoptions+=n,V
"set tabstop=8 		" sets the width of tab character,V
n,v
nmap <A-s> <Esc>:w<Enter>,V
C,v
nmap <C-s> <Esc>:w<Enter>vmap <A-s> <Esc>:w<Enter>,V
vmap <A-s> <Esc>:w<Enter>nmap <C-s> <Esc>:w<Enter>,V
A,v
i,v
imap <A-a> <Esc>vmap <A-a> <Esc>" reformat paragraphnmap <A-r> gwap         imap <A-r> <Esc>gwapaimap <A-v> <Esc>vaimap <C-s> <Esc>:w<Enter>vmap <C-s> <Esc>:w<Enter>nmap <C-s> <Esc>:w<Enter>imap <C-e> <Esc>$anmap <C-a> <Esc>^i,v
" reformat paragraph,v
call pathogen#infect() ,V
source ~/.vim_runtime/vimrcs/myedits.vim,V
function! VisualSelection(direction, extra_filter) range    let l:saved_reg = @"    execute "normal! vgvy"    let l:pattern = escape(@", '\\/.*$^~[]')    let l:pattern = substitute(l:pattern, "\n$", "", "")    if a:direction == 'b'        execute "normal ?" . l:pattern . "^M"    elseif a:direction == 'gv'        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)    elseif a:direction == 'replace'        call CmdLine("%s" . '/'. l:pattern . '/')    elseif a:direction == 'f'        execute "normal /" . l:pattern . "^M"    endif    let @/ = l:pattern    let @" = l:saved_regendfunction,v
set whichwrap+=<,>,h,l,[,] " allows for cursor wrappingset wrap            " allow word wrappingset linebreak       " set nolist          " list disables linebreakset tabstop=4		" use # of chars to display a <TAB> set shiftwidth=4	" insert # of chars in autoindentset softtabstop=4	" insert # of chars when pressing <TAB>set autoindent		" auto indentationset copyindent		" copy the previous indentation on autoindentingset smartindent	" smart indentation for C-like language"set cindent		" smart indentation especially for C languageset smarttab		" insert tabs on the start of a line according to                         " context,v
class SpectralTile(object):    """ Subclass of Tile.    """    guesses = None    ncomps = None    params = None    residuals = None    gridXPos = None    gridYPos = None    imageXPos = None    imageYPos = None    xOffset = None    yOffset = None    visited = False    fitSuccess = False    profile = None    noise = None    noiseProfile = None    compAreaList = []    fit_chi2 = None    fValuePlusList = []    fValueMinusList = []    spectral_axis = None    coVelocities = None    def __init__(self,gridXPos = None,gridYPos = None,                 imageXPos = None, imageYPos = None,                 profile = None, tile = None,                 box = None):        """ Create a tile use a pyspeckit Cube instance.        tile : SpectralTile            Copies parameters from input tile to new tile.        """        import numpy as np        if tile is None:            self.guesses = None            self.ncomps = None            self.params = None            self.gridXPos = gridXPos            self.gridYPos = gridYPos            self.imageXPos = imageXPos            self.imageYPos = imageYPos            self.xOffset = box[0]            self.yOffset = box[1]            self.profile = profile            self.fitSuccess = False            self.visited = False        # Copy tile parameters to new tile        if tile is not None:            self.guesses = tile.guesses            self.ncomps = tile.ncomps            self.params = tile.params            self.residuals = tile.residuals            self.visited = tile.visited            self.fitSuccess = tile.fitSuccess            self.profile = tile.profile            self.noise = tile.noise            self.noiseProfile = tile.noiseProfile            self.compAreaList = tile.compAreaList            self.fit_chi2 = tile.fit_chi2            self.gridXPos = tile.gridXPos            self.gridYPos = tile.gridYPos            self.imageXPos = tile.imageXPos            self.imageYPos = tile.imageYPos            self.xOffset = tile.yOffset            self.yOffset = tile.xOffset            self.fValuePlusList = tile.fValuePlusList            self.fValueMinusList = tile.fValueMinusList            self.spectral_axis = tile.spectral_axis            self.coVelocities = tile.coVelocities    def calculate_compArea(self,compNumber,spectral_axis):        """ Caclutes area under gaussian.        """        from scipy.integrate import quad        a = spectral_axis.min()        b = spectral_axis.max()        params = self.get_compParams(compNumber)        return quad(self.gaussian,a,b,args=(params[0],params[1],params[2]))[0]    def calculate_compAreaList(self,spectral_axis):        """ Calculates areas of gaussian components in profile fit.        """        compAreaList = []        for i in xrange(0,self.ncomps):            area = self.calculate_compArea(i,spectral_axis)            compAreaList.append(area)        self.compAreaList = sorted(compAreaList)        tempParams = []        # Sort gaussian parameters by area        for i in xrange(0,self.ncomps):            new_params = self.params[compAreaList.index(sorted(compAreaList)[i])]            tempParams.append(new_params)        self.params = tempParams    def calculate_noise(self,xarr,lowrange,highrange):        """ Calculates rms noise of Tile profile given velocity ranges.        """        velMin = [lowrange[0],highrange[0]]        velMax = [lowrange[1],highrange[1]]        std = 0        if self.profile is not None:            for k in xrange(len(velMin)):                noiseRegion = np.where((xarr >= velMin[k]) & \                                (xarr <= velMax[k]))                std = np.std(self.get_profile()[noiseRegion]) + std            std = std / len(velMin)            self.noise = std        else:            self.noise = np.NaN    def calculate_noiseScale(self,Tsys):        """ Creates an array for scaling the noise by (Tsys + Tb) / Tsys        """        if self.has_validProfile():            profile = self.get_profile()            n = np.zeros(len(profile))            for i, Tb in enumerate(profile):                n[i] = (Tsys + Tb) / Tsys * self.noise            self.noiseProfile = n    def fit_profile(self,spectral_axis,guesses=None,ncomp=None,co_tile=None,                    co_width_scale=1.):        """ Perform a gaussian decomposition on the profile.        """        from agpy.gaussfitter import multigaussfit as gfit        from numpy import where,zeros,linspace,array,unique        from numpy import concatenate as concat        import numpy as np        self.guesses = guesses        # define mask for spectral axis        mask = np.ones(spectral_axis.shape,dtype=bool)        # Determine extent of CO        if co_tile is not None:            if co_tile.ncomps is not None and co_tile.ncomps > 0:                #vels = zeros(len(co_tile.params))                #widths = zeros(len(co_tile.params))                ## Get velocities and widths of components                #for i in range(len(co_tile.params)):                #    vels[i] = co_tile.params[i][1]                #    widths[i] = co_tile.params[i][2]                vels = []                widths = []                for i in range(len(co_tile.params)):                    if co_tile.params[i][0] > 3*co_tile.noise:                        vels.append(co_tile.params[i][1])                        widths.append(co_tile.params[i][2])                vels = np.asarray(vels)                widths = np.asarray(widths)                # lower and higher velocity extent of components:                minVels = vels - co_width_scale*widths                maxVels = vels + co_width_scale*widths                self.coVelocities = []                velpos = array([])                for i in range(len(minVels)):                    # Define pixels excluded from CO region                    velpos_temp = where((spectral_axis > minVels[i]) & \                                        (spectral_axis < maxVels[i]))[0]                    mask[velpos_temp] = 0                    # Define velocities included in CO region                    coVels = spectral_axis[(spectral_axis > minVels[i]) & \                                          (spectral_axis < maxVels[i])]                    self.coVelocities.append(coVels)                # now determine unique pixels                # velpos = unique(velpos).astype(int)                # Remove profile pixels within CO region                xarray = spectral_axis[mask]                profile = self.profile[mask]                noiseProfile = self.noiseProfile[mask]            else:                xarray = spectral_axis                profile = self.profile                noiseProfile = self.noiseProfile                velpos=linspace(1,len(profile),len(profile))        else:            xarray = spectral_axis            profile = self.profile            noiseProfile = self.noiseProfile            velpos=linspace(1,len(profile),len(profile))        # Fit the profile        if guesses != [0,0,0]:            # force high amplitude guesses to a threshold            for i in range(len(guesses)/3):                if guesses[i*3] > 1.1*self.profile.max():                    guesses[i*3] = self.profile.max()            fit = gfit(xarray,                    profile,                    ngauss=ncomp,                    err=noiseProfile,                    params=self.guesses,                    limitedmin=[True,True,True]*ncomp,                    limitedmax=[True,True,False]*ncomp,                    minpars=[0,spectral_axis.min(),0],                    maxpars=[1.1*self.profile.max(),spectral_axis.max(),0])            self.fitSuccess = True        else:            self.residuals = self.profile            self.fitSuccess = False        # Set class variables        if self.fitSuccess:            self.residuals = zeros(len(self.profile))            for i in range(len(profile)):                if mask[i]:                    self.residuals[i] = profile[i] - fit[1][i]            tempParams = fit[0]            self.params = []            self.ncomps = 0            self.fit_chi2 = fit[3]            self.spectral_axis = spectral_axis            # Write gaussian component parameters to Tile, ignore comps with            # amp=0 or width=0            for i in xrange(0,ncomp):                if tempParams[i*3] > self.noise * 0. \                        and tempParams[i*3 + 2] != 0:                    self.params.append(tempParams[i*3:i*3+3])                    self.ncomps = self.ncomps + 1            self.calculate_compAreaList(spectral_axis)    def gaussian(self,x,amp,shift,width):        """ Returns gaussian with amp, shift, width, at position x.        """        return amp * np.exp( - (x - shift)**2 / (2. * width**2))    def get_chi2(self):        return self.fit_chi2    def get_compAreaList(self):        return self.compAreaList    def get_compParams(self,compNumber):        """ Extracts parameters of fit from compNumber.        Parameters are returned as a list in the format:        [amplitude,shift,width]        """        if self.params is not None:            if compNumber > self.ncomps:                print 'Number of components in spectrum is ' + str(self.ncomps)                print '\n' + 'Please choose a valid component.'            else:                return self.params[compNumber]    def get_guesses(self):        return self.guesses    def get_ncomps(self):        """ Returns number of components in a fit.        """        return self.ncomps    def get_noise(self):        return self.noise    def get_noiseProfile(self):        return self.noiseProfile    def get_params(self):        return self.params    def get_position(self):        """ Returns a tuple of the x and y position of the Tile.        """        return (self.gridXPos,self.gridYPos)    def get_profile(self):        return self.profile    def get_residuals(self):        """ Returns residuals.        """        return self.residuals    def get_componentVelocities(self):        """ Returns velocities of components.        """        vels = np.zeros(self.ncomps)        for i in range(0,self.ncomps):            vels[i] = self.params[i][1]        return vels    def has_validProfile(self):        """ Determines whether a profile exists for the tile.        """        if self.profile is None:            return False        else:            return True    def is_fitSuccessful(self):        """ Returns whether the tile profile fit was successful.        """        return self.fitSuccess    def is_visited(self):        """ Returns whether a gaussian has been fit to the tile profile.        """        return self.visited    def make_component(self,compNumber,spectral_axis):        """ Creates a component using fit parameters.        Returns a 1D numpy array.        """        if self.params is None:            print '\n Warning: Fit has not been performed, \n' + \                ' or fit has failed. \n' + \                ' No parameters are available.'        else:            amp = self.params[compNumber][0]            shift = self.params[compNumber][1]            width = self.params[compNumber][2]            return self.make_gaussian(spectral_axis,amp,shift,width)    def make_gaussian(self,xarr,amp,shift,width):        """ Creates a gaussian shape over across an axis using gaussian        parameters.        """        gaussArray = np.zeros(len(xarr))        for i, x in enumerate(xarr):            gaussArray[i] = self.gaussian(x,amp,shift,width)        return gaussArray    def set_noise(self,noise):        """ Sets noise of profile.        """        self.noise = noise    def set_visited(self):        """ Sets the Tile as visited.        """        self.visited = True    def subtract_baseline(self,xarr,lowrange,highrange):        """ Subtracts a first-degree polynomial baseline from the profile.        """        from pylab import polyfit        tempProfile = self.profile        fitRegion = []        velMin = [lowrange[0],highrange[0]]        velMax = [lowrange[1],highrange[1]]        for k in xrange(len(velMin)):            tempRegion = np.where((xarr >= velMin[k]) & \                    (xarr <= velMax[k]))[0]            for i in range(len(tempRegion)):                fitRegion.append(tempRegion[i])        m,b = polyfit(xarr[fitRegion], self.profile[fitRegion], 1)        self.profile = tempProfile - (m * xarr + b)    def calculate_noise(self,xarr,lowrange,highrange,noiseScale=None):        """ Calculates rms noise of Tile profile given velocity ranges.        """        if noiseScale is None:            noiseScale = 1.        std = 0        velMin = [lowrange[0],highrange[0]]        velMax = [lowrange[1],highrange[1]]        if self.profile is not None:            for k in xrange(len(velMin)):                noiseRegion = np.where((xarr >= velMin[k]) & \                                (xarr <= velMax[k]))                std = np.std(self.get_profile()[noiseRegion]) + std            std = std / len(velMin)            self.noise = std * noiseScale        else:            self.noise = np.NaN,V
vimrcs/extended.vim,v
    # Class variables ;alskd ksdflks  ;alskd ksdflks  ;alskd ksdflks  ;alskd ksdflks  ;alskd ksdflks  ;alskd ksdflks  ;alskd ksdflks  ;alskd ksdflks ,V
